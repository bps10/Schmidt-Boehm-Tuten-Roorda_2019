---
title: ' Spatial summation of signals from individual cones in human color vision'
author: '[Brian P. Schmidt](https://bps10.github.io), Alexandra E. Boehm, William S. Tuten, Austin Roorda'
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
  html_notebook: default
---


```{r results="hide", message=FALSE, echo=FALSE}
setwd("~/R/TwoConeColorSummation")
library(tidyverse)
library(ggthemes)
library(gridExtra)
library(corrplot)
library(car)

# set the colors that will be used in plots below.
red <- "#e84040"
green <-"#40c631"
blue <- "#4042e8"
yellow <- "#e8df40"
gray <- "#595959"
```

```{r, message=FALSE, echo=FALSE}
trial_data <- read_csv('filtered_data.csv')

head(trial_data)
```
individually.

```{r, warning=FALSE, echo=FALSE, message=FALSE}

singleConesSummary <- trial_data %>%
  select(., -typeIDstr) %>%
  filter(., isPair==FALSE) %>% 
  group_by(., subject, session, masterID1) %>%   
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length >= minTrials) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

twoConesSummary <- trial_data %>%
  select(., -typeIDstr) %>%
  filter(., isPair==TRUE) %>% 
  group_by(., subject, session, masterID1, masterID2) %>%
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length >= minTrials) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

merged1 <- merge(twoConesSummary, 
           select(singleConesSummary, subject, 
                  session, masterID1, yb, gr, lConeNeighbors), 
           by=c("subject", "session", "masterID1")) %>% 
  rename(., yb12=yb.x, gr12=gr.x, yb1=yb.y, gr1=gr.y,
                  lConeNeighbors12=lConeNeighbors.x, 
                  lConeNeighbors1=lConeNeighbors.y)

sessionMerge <- merged1 %>% 
  merge(., select(singleConesSummary, subject, session,
                  masterID1, yb, gr, lConeNeighbors), 
        by.x=c("subject", "session", "masterID2"),
        by.y=c("subject", "session", "masterID1")) %>% 
  rename(., yb2=yb, gr2=gr, lConeNeighbors2=lConeNeighbors) %>%
  mutate(., saturation12=abs(yb12) + abs(gr12),
         saturation1=abs(yb1) + abs(gr1),
         saturation2=abs(yb2) + abs(gr2))
```

We then fit a linear model to the data. Behavioral reports from two cone stimulation were predicted by an average of the individual responses: $gr_{12} = (gr_1 + gr_2) / 2$. Below is a visualization of the measured responses against the predictions.


```{r, echo=FALSE}
sessionMerge['predictedYB'] = (sessionMerge$yb1 + sessionMerge$yb2) / 2
sessionMerge['predictedGR'] = (sessionMerge$gr1 + sessionMerge$gr2) / 2
sessionMerge['predictedSaturation'] = abs(sessionMerge$predictedYB) + abs(sessionMerge$predictedGR)

# Add a column w difference from prediction
sessionMerge <- mutate(sessionMerge, 
                       diff_from_prediction=saturation12 - predictedSaturation)

```


```{r}

(error_plot <- sessionMerge %>%
  ggplot(., aes(x=abs(gr1 - gr2), y=abs(gr12 - predictedGR), color=as.factor(typeID))) +
  geom_point() +
  scale_color_manual(values = c(gray, green, yellow, red), 
                     name="spectral type",
                     labels = c("unknown", "M+M", "L+M", "L+L")) +
  geom_smooth(method=lm) +
  #coord_equal(xlim=c(0, 1)) +
  #labs(x='|gr_1 - gr_2|', y='observed gr_12 - predicted gr_12') + 
  theme_classic(base_size=15)
)
ggsave('figures/error_plot.pdf')
ggsave('figures/error_plot.png')

```

```{r}
library(plotly)

p <- sessionMerge %>%
  plot_ly(., x = ~gr1, y = ~gr2, z = ~gr12,
          color = ~typeID,
          colors = c(gray, green, red, green, yellow, red)
          ) %>%
  add_markers() %>%
 # coord_equal(xlim=c(-1, 1)) %>%
layout(scene = list(xaxis = list(title = 'cone 1 (gr)'),
                     yaxis = list(title = 'cone 2 (gr)'),
                     zaxis = list(title = 'cone 1+2 (gr)')))

# Create a shareable link to your chart
# Set up API credentials: https://plot.ly/r/getting-started
#chart_link = api_create(p, filename="scatter3d-basic")
#chart_link

```
[
Results of linear regression (gr dimension followed by yb):
```{r, echo=FALSE}
# A linear model predicts the results based on an average of the individual responses.
mod <- lm(gr12 ~ predictedGR, sessionMerge)
summary.lm(mod)

mod <- lm(yb12 ~ predictedYB, sessionMerge)
summary.lm(mod)
```


## Pairs with the same type are more saturated than predicted by average

A simple linear model captured a large fraction of the variance (>72%). However, there were some pairs that deviated substantially from the best fit line. We wondered whether the deviation from linearity might be predicted by the sub-class of the two cones. For instance, do an L- and M-cone interact in a non-linear manner, while two L or two M-cones sum linearly?

We found the saturation for each pair and subtracted it from the average of the two cones probed alone. Those results are plotted below. A unity line represents the condition where the observed saturation judgment was predicted exactly by the average of individual responses. Notice that the L+L and M+M pairs tend to fall above the unity line -- particularly at higher saturation values. In contrast, the L+M pairs fall below the line. These observations indicate that the cones with the same spectral type produced slightly more saturated reports than predicted by the average of their individual responses.

```{r}
sig <- function (in_, theta) {
  return(2 * (1 / (1 + exp(-in_ * theta))) - 1)
}

compress <- function(input, k) {
  return(input ^ k)
}

oneCone = seq(-1, 1, 0.05)
theta <- 1.25
in_ <- -seq(-2, 2, 0.05)
qplot(x=in_, y=sig(in_, theta))

predictionGR <- sig(sessionMerge$gr1, theta) + sig(sessionMerge$gr2, theta)
predictionYB <- sig(sessionMerge$yb1, theta) + sig(sessionMerge$yb2, theta)
sessionMerge["predictionNonLin"] <- abs(predictionGR) + abs(predictionYB)

(sum((sessionMerge$saturation12 - sessionMerge$predictedSaturation) ^ 2) / length(sessionMerge$saturation12))
(sum((sessionMerge$saturation12 - sessionMerge$predictionNonLin) ^ 2) / length(sessionMerge$saturation12))

sessionMerge %>% 
  filter(., typeID == 1| typeID > 3) %>%
  ggplot(., aes(x=predictionNonLin, y = saturation12, color=as.factor(typeID))) +
  geom_point() +
  coord_equal(xlim=c(0, 1), ylim=c(0, 1)) +
  scale_color_manual(values = c(gray, green, yellow, red), name="spectral type",
                     labels = c("unknown", "M+M", "L+M", "L+L")) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) + 
  geom_smooth(method=lm, inherit.aes = FALSE, aes(x=predictionNonLin, y = saturation12)) +
  xlab('predicted saturation') +
  ylab('measured saturation') +
  theme_classic(base_size=15) +
  theme(legend.position='none')


(diffHist <- sessionMerge %>%
   filter(., typeID == 1 | typeID > 3) %>%
   ggplot(., 
          aes(x=saturation12 - predictionNonLin, 
              color=as.factor(typeID))) + 
  geom_freqpoly(binwidth=0.1, size=1.25) +
  scale_color_manual(
    values = c(gray, green, yellow, red), 
    name="spectral type",
    labels = c("unknown-pair", "M+M", "L+M", "L+L")) + 
  xlab("measured - predicted saturation") +
  theme_classic(base_size=15) +
  theme(legend.position=c(0.75, 0.80))
)
  
```
# Conclusions

Color sensations from pairs of cones were predicted by a simple average of individual responses. However, when two cones from the same subclass were probed, there was a systematic deviation from a simple average. These pairs produced significantly more saturated colors than predicted by an average of the colors elicited when probed alone. This observation suggests that the visual system uses a different strategy when combining information within versus across neuronal sub-classes.

