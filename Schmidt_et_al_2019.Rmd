---
title: ' Spatial summation of signals from individual cones in human color vision'
author: '[Brian P. Schmidt](https://bps10.github.io), Alexandra E. Boehm, William S. Tuten, Austin Roorda'
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
  html_notebook: default
---


# Abstract

Primary sensory neurons provide an organisms with real-time information about the environment. At an individual scale, the signals conveyed by sensory neurons are noisy and ambiguous. One strategy for reducing uncertainty is to pools signals across multiple detectors. Under low light conditions, for example, the visual system integrates information across cone photoreceptors. How signals from cones are pooled in daylight to produce color sensation is not known at a cellular scale. We used an adaptive optics microstimulator to target individual and pairs of cones with light and recorded the associated percept. Our findings demonstrate that, on small scales, the visual system averages information across cones when generating color sensations.

# Introduction

How are signals from single neurons combined in the brain?


# Experimental Methods

Two male and one female subject were enrolled in the study. Each session began by capturing a high-resolution image of the subjectâ€™s cone mosaic. From that image, three contiguous cones were selected for study (Figure 1A). During each trial of the session, the selected cones were targeted with small spots of light (543 nm; 0.35 arcmin; 500 ms) following established procedures (Harmening et al. 2014). The intensity of each spot was fixed based on threshold judgments (85% frequency of seeing) made prior to the start of the experiment. Subjects judged the hue and saturation of each trial with a scaling procedure (Schmidt et al. 2018).  Each cone and pair were tested 12 times; trials were randomly interleaved. The background in both experiments was a low photopic white (40 cd/m2). Cone mosaics were classified (L,M,S) with AOSLO densitometry in two subjects (Sabesan et al. 2015).

# Data processing

1. Load data from CSV file. This file contains more than 4,000 trials that were completed by the three subjects. Below we will convert the type of a few columns, filter out bad trials and compute some summary statistics to do sanity checks. 

```{r loadData, results="hide", message=FALSE}
setwd("~/R/TwoConeColorSummation")
library(tidyverse)
library(car)
library(RColorBrewer)
library(ggthemes)

trial_data <- read_csv('all_trial_data.csv')
# remove the first column which is a zerobased index created in Pandas
trial_data <- trial_data %>% select(-X1)
```

```{r}
head(trial_data)
```

2. The column isPair is meant to be a logical.
```{r}
trial_data <- mutate(trial_data, isPair=as.logical(isPair))
```

3. Filter out trials with bad deliveries. Bad deliveries are defined as errors greater than 0.35 arcmin. In those trials, we cannot be confident that the correct cone was targeted. Values below 0.01 indicate that there was a problem with the delivery because a value of 0 error cannot occur naturally.
```{r}
trial_data <- filter(trial_data, delivery_error < 0.35)
trial_data <- filter(trial_data, delivery_error > 0.01)
```

4. Compute frequency of seeing (FoS) for S- and L/M-cones. FoS serves as a sanity check: it should be close to zero in the case of S-cones (because they are insensitive to the stimulus) and 0.85 in the case of L/M-cones (because we set it there).
```{r}
Scones <- filter(trial_data, type1 == 1 | type2 == 1)
Scones <- filter(Scones, isPair == FALSE)

FoS <- sum(!is.na(Scones$by)) / length(Scones$delivery_error)
FoS

FoS <- sum(!is.na(trial_data$by)) / length(trial_data$delivery_error)
FoS

```

5. Remove S-cones and not seen trials. S-cones are controls and are not needed for further analysis. 

```{r}
trial_data <- filter(trial_data, type1 != 1 | type2 != 1)
trial_data <- filter(trial_data, !is.na(by))
```

6. Add a type ID where 1M=2, 1L=3, 2M=4, L+M=5, 2L=6 and unknown = 0. The data set contains trials in which individual or pairs of cones were stimulated. For some analyses, we want to know the type tested and whether it was a pair or a single cone. Now that we have removed S-cones from the data, the only possible values are 2, 3, 4, 5, 6 and 0 (the mosaic from subject 20075 has not been classified).
```{r}
trial_data <- mutate(trial_data, 
                     typeID=if_else(trial_data$isPair, 
                                    trial_data$type1 + trial_data$type2,
                                    trial_data$type1))
```

7. Compute saturation and add it as a column. Below we see a plot of saturation as a function of type ID. There are no systematic differences besides ID=0, which are unclassified cones from S20075.
```{r saturation, fig.height=3, fig.width=9}
trial_data <- mutate(trial_data, saturation = abs(by) + abs(rg))

ggplot(trial_data, aes(x=saturation)) + 
  geom_histogram(binwidth=0.1) + facet_grid(. ~ typeID)
```

8. Finally, we summarize delivery error and plot a histogram. The resulting distribution is close to normal with a mean of 0.19 arcmin and a standard deviation of 0.036. 4,087 trials were included in the analysis.
```{r delivery, fig.height=3}
summarize(trial_data, mean=mean(delivery_error), 
          std=sd(delivery_error), N=length(delivery_error))

g <- ggplot(trial_data, aes(delivery_error)) + 
  geom_histogram(bins = 30)
g
```

# Results

## Variability in sensations from cones with the same sensitivity

We first grouped each trial based on the subject, cone targeted (masterID) and type of cone or pair probed. We then found them mean of each group and plotted blue-yellow (by) and red-green (rg) dimensions below. The plot provides a sense that the typeID was predictive of the color report (not shown further here). In both subjects with classified cones, typeID 2 and 4 produced rg means that were greater than zero, while 3 and 6 led to negative values. This is interesting because typeID=2 & 4 are when a single or pair of M-cones were targeted and 3 & 6 were when one or two L-cones were targeted. As a first pass, this suggests that cone type may be predictive of the color reported by the subject. 

```{r}
(typeGroup <- trial_data %>%
  group_by(., subject, typeID) %>% 
  summarise(., by_mean=mean(by), by_std=sd(by), 
            rg_mean=mean(rg), rg_std=sd(rg), N=length(rg))
 )

```

```{r}
singleAndPairs <- trial_data %>%
  group_by(., subject, masterID1, masterID2) %>% 
  summarise_all(., mean)

boundary <- data.frame(x=c(-1, 0, 1, 0, -1), y=c(0, 1, 0, -1, 0))

ggplot(data=singleAndPairs, aes(x=by, y=rg, color=as.factor(typeID))) + 
  geom_point(alpha=0.6, size=0.4) +
  facet_grid(. ~ subject) +
  geom_rug(alpha=0.4) + 
  coord_equal(xlim=c(-1, 1), ylim=c(-1, 1)) + 
  xlab('(yellow - blue) / total') + ylab('(green - red) / total') + 
  scale_color_manual(
    values = c("black", "#3aaf4f", "#d1463e", "#3aaf4f", "#AAAA00", "#d1463e"), 
    name="spectral type",
    labels = c("unknown", "M", "L", "M+M", "L+M", "L+L")) +
  #scale_color_brewer(palette = "Spectral") +
  geom_path(data = boundary, aes(x=x, y=y), colour='gray', linetype=2) +
  theme_bw()

ggsave("lms_UAD.pdf")
```

There are a few additional features to notice. Firstly, there is some individual variability. S20075 used blue more frequently than the two other subjects and S10001 did not report yellow in any trials. However, the general patterns are similar. Most of the variance was found along the green-red dimension and there were no points that fell in the blueish-red or greenish-yellow dimension. In the two subjects with classified mosaics, we additionally see that L-cone targeted trials tended to fall along the red region of this space, while M-cones were more likely to fall in the green dimension.

## Mosaic parameters do not predict responses

Next, we grouped the data according to the number of cones targeted (one or two), the session in which trial occurred and the specific cone(s) that was targeted. The mean and count was then computed for each cone(s). Next, we select only those cones pairs which had at least four good trials. Finally, the length columns are dropped and columns are renamed to remove "_mean" so that the original names are preserved.

```{r}
singleConesSummary <- trial_data %>% 
  filter(., isPair==FALSE) %>% 
  group_by(., subject, session, masterID1) %>%   
  summarise_all(., c("mean", "length")) %>%
  filter(., by_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

twoConesSummary <- trial_data %>% 
  filter(., isPair==TRUE) %>% 
  group_by(., subject, session, masterID1, masterID2) %>%
  summarise_all(., c("mean", "length")) %>%
  filter(., by_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))
```

Using the data generated above, we visualized the relationship between measured response dimensions and predictor variables for the one and two cone conditions.

```{r}
# scatterplotMatrix with car package
scatterplotMatrix(singleConesSummary[ ,c("by", "rg", "saturation", 
                                         "lConeNeighbors")],
                  diagonal=list(method ="histogram"),
                  ellipse=FALSE)

scatterplotMatrix(twoConesSummary[ ,c("by", "rg", "saturation", 
                                      "lConeNeighbors",
                                      "distance_btwn_cones_pix")],
                  diagonal=list(method ="histogram"),
                  ellipse=FALSE)
```


None of the above correlation plots demonstrate a strong relationship. The local neighborhood surrounding a cone is typically thought to be an important factor in generating color sensations. However, we do not find a strong relationship. We also did not observe a strong relationship between the distance between cones (plotted here in pixels) and color or saturation judgments. Cone pairs were never separated by more than one cone, which likely explains why there was no relationship.

## Two cone responses are an average of individual reports

Next, we were interested in whether the reports from from each individual cones in a pair predicted the color they produced when stimulated together. To answer this question, we created a merged data frame with the responses from each individual cone matched up with the judgments from their paired stimulation.

```{r}

singleConesSummary <- trial_data %>% 
  filter(., isPair==FALSE) %>% 
  group_by(., subject, session, masterID1) %>%   
  summarise_all(., c("mean", "length")) %>%
  filter(., by_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

twoConesSummary <- trial_data %>% 
  filter(., isPair==TRUE) %>% 
  group_by(., subject, session, masterID1, masterID2) %>%
  summarise_all(., c("mean", "length")) %>%
  filter(., by_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

merged1 <- merge(twoConesSummary, 
           select(singleConesSummary, subject, 
                  session, masterID1, by, rg, lConeNeighbors), 
           by=c("subject", "session", "masterID1")) %>% 
  rename(., by12=by.x, rg12=rg.x, by1=by.y, rg1=rg.y,
                  lConeNeighbors12=lConeNeighbors.x, 
                  lConeNeighbors1=lConeNeighbors.y)

sessionMerge <- merged1 %>% 
  merge(., select(singleConesSummary, subject, session,
                  masterID1, by, rg, lConeNeighbors), 
        by.x=c("subject", "session", "masterID2"),
        by.y=c("subject", "session", "masterID1")) %>% 
  rename(., by2=by, rg2=rg, lConeNeighbors2=lConeNeighbors) %>%
  mutate(., saturation12=abs(by12) + abs(rg12),
         saturation1=abs(by1) + abs(rg1),
         saturation2=abs(by2) + abs(rg2))
```


After merging and sorting the data, we fit a linear model to the data, which predicts behavioral reports from two cone stimulation based on an average of the individual responses: $rg_{12} = (rg_1 + rg_2) / 2$. Below is a visualization of the measured responses against the predictions.


```{r}
unity = data.frame(x=c(-1, 1), y=c(-1, 1))
ggplot(data=sessionMerge, aes(x=(rg1 + rg2) / 2, y=rg12)) + 
  geom_point() +
  geom_smooth(method=lm) +
  coord_equal(xlim=c(-1, 1), ylim=c(-1, 1)) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  ggtitle('green - red / total') +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  xlab('average of individual responses') + ylab('observed two-cone response') + 
  theme_classic(base_size=15)

ggsave("prediction_rg.pdf")
```

```{r}
# A linear model predicts the results based on an average of the individual responses.
mod <- lm((rg1 + rg2) / 2 ~ rg12, sessionMerge)
summary.lm(mod)
```


## Pairs with the same type are more saturated than predicted by average

Finally, we look at the error terms of our prediction as a function of the cone types probed.

```{r}
# Add a column w difference from prediction
sessionMerge <- mutate(sessionMerge, 
                       diff_from_prediction=saturation12 - 
                         ((saturation1 + saturation2) / 2))

```

Notice that the L+L and M+M pairs tend to fall above the unity line. This is especially true as saturation increases. In contrast, the L+M pairs fall below the line. These observations indicate that the cones with the same spectral type produced slightly more saturated reports than predicted by the average of their individual responses.

```{r}
ggplot(data=filter(sessionMerge, typeID > 3), 
       aes(x=(saturation1 + saturation2) / 2, y=saturation12, color=as.factor(typeID))) + 
  geom_point() + 
  coord_equal(xlim=c(0, 1), ylim=c(0, 1)) +
  scale_color_manual(values = c("green", "yellow", "red"), name="spectral type",
                     labels = c("M+M", "L+M", "L+L")) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) + 
  xlab('predicted saturation (average of individual)') +
  ylab('measured saturation') +
  theme_classic(base_size=15)

```

These trends were quantified directly by taking the difference between the observed and predicted saturation judgments. The histogram below illustrates the point outlined above. As the t-test's below demonstrate, the L+M pairs were significantly less saturated (more white) than a simple average of their individual responses, while the opposite was true for cones with the same spectral type.

```{r}
ggplot(data=filter(sessionMerge, typeID > 3), 
       aes(x=saturation12 - ((saturation1 + saturation2) / 2), 
           color=as.factor(typeID))) + 
  geom_freqpoly(binwidth=0.1) +
  scale_color_manual(
    values = c("green", "yellow", "red"), 
    name="spectral type",
    labels = c("M+M", "L+M", "L+L")) + 
  xlab("observed - predicted saturation") +
  theme_classic(base_size=15)

ggsave('observed-predicted_histogram.pdf')

```


```{r}

t.test(sessionMerge %>% 
         filter(., typeID == 5) %>% 
         select(., diff_from_prediction)
       )
t.test(sessionMerge %>% 
         filter(., typeID == 4 | typeID == 6) %>%
         select(., diff_from_prediction)
       )

t.test(sessionMerge %>% 
         filter(., typeID == 5) %>% 
         select(., diff_from_prediction),
       sessionMerge %>% 
         filter(., typeID == 4 | typeID == 6) %>%
         select(., diff_from_prediction)
       )
```

# Conclusions

Color sensations from pairs of cones were predicted by a simple average of individual responses. However, when two cones from the same subclass were probed, there was a systematic deviation from an average. These pairs produced significantly more saturated colors than predicted by an average of the colors elicited when probed alone.

