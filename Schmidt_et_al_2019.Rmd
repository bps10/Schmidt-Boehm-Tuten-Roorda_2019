---
title: ' Spatial summation of signals from individual cones in human color vision'
author: '[Brian P. Schmidt](https://bps10.github.io), Alexandra E. Boehm, William S. Tuten, Austin Roorda'
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document:
    df_print: paged
  html_notebook: default
---


# Abstract

Primary sensory neurons provide an organisms with real-time information about the environment. At an individual scale, the signals conveyed by sensory neurons are noisy and ambiguous. One strategy for reducing uncertainty is to pools signals across multiple detectors. Under low light conditions, for example, the visual system integrates information across cone photoreceptors. How signals from cones are pooled in daylight to produce color sensation is not known at a cellular scale. We used an adaptive optics microstimulator to target individual and pairs of cones with light and recorded the associated percept. Our findings demonstrate that, on small scales, the visual system averages information across cones when generating color sensations.

# Introduction

How are signals from single neurons combined in the brain?


# Experimental Methods

Two male and one female subject were enrolled in the study. Each session began by capturing a high-resolution image of the subjectâ€™s cone mosaic. From that image, three contiguous cones were selected for study (Figure 1A). During each trial of the session, the selected cones were targeted with small spots of light (543 nm; 0.35 arcmin; 500 ms) following established procedures (Harmening et al. 2014). The intensity of each spot was fixed based on threshold judgments (85% frequency of seeing) made prior to the start of the experiment. Subjects judged the hue and saturation of each trial with a scaling procedure (Schmidt et al. 2018).  Each cone and pair were tested 12 times; trials were randomly interleaved. The background in both experiments was a low photopic white (40 cd/m2). Cone mosaics were classified (L,M,S) with AOSLO densitometry in two subjects (Sabesan et al. 2015).

# Data processing

Below we will load the raw data and do some light processing: including filtering out bad trials and computing summary statistics and sanity checking. 

1. The raw trial data was read from a CSV file. The dataset contains nearly 5,000 trials completed by three subjects.

```{r loadData, results="hide", message=FALSE}
setwd("~/R/TwoConeColorSummation")
library(tidyverse)
library(car)
library(RColorBrewer)
library(ggthemes)

trial_data <- read_csv('all_trial_data.csv')
# The column isPair is meant to be a logical.
trial_data <- mutate(trial_data, isPair=as.logical(isPair))
summary(trial_data)

```

2. Trials with bad deliveries were removed from the data set. Bad deliveries are defined as errors greater than 0.35 or less than 0.01 arcmin (values below 0.01 do not occur naturally). In those trials, we cannot be confident that the correct cone was targeted.
```{r}
trial_data <- trial_data %>%
  filter(., delivery_error < 0.35) %>%
  filter(., delivery_error > 0.01)
```

After removing bad trials (3.6%), 4,788 trials remained for further analysis. Below, we see the distribution of delivery errors was roughly normal with a mean of 0.19 arcmin and a standard deviation of 0.036. 

```{r delivery, fig.height=3}
summarize(trial_data, mean=mean(delivery_error), 
          std=sd(delivery_error), N=length(delivery_error))

ggplot(trial_data, aes(delivery_error)) + 
  geom_histogram(bins = 30)
```

3. Frequency of seeing (FoS) was computed for S- and L/M-cones. FoS serves as a sanity check: it should be close to zero when an S-cone was targeted (because they are insensitive to the stimulus) and 0.85 in the case of L/M-cones (because that is the threshold we set with the detection task).

```{r}
Scones <- filter(trial_data, type1 == 1 | type2 == 1)
Scones <- filter(Scones, isPair == FALSE)

(FoS <- sum(!is.na(Scones$yb)) / length(Scones$delivery_error))

(FoS <- sum(!is.na(trial_data$yb)) / length(trial_data$delivery_error))


```

4. Trials that either targeted an S-cone or the subject did not see were not analyzed further. 

```{r}
trial_data <- filter(trial_data, type1 != 1 | type2 != 1)
trial_data <- filter(trial_data, !is.na(yb))
```

5. The remaining dataset contains trials in which individual or pairs of L- and M-cones were stimulated. For some analyses, we want to know both the type tested and whether it was a pair or a single cone. To facilitate these analyses, a type ID was created in which 1M=2, 1L=3, 2M=4, L+M=5, 2L=6 and unknown = 0. Note: S-cones were already removed from the data. Tthe mosaic of subject 20075 has not been classified.
```{r}
trial_data <- trial_data %>%
  mutate(., typeID=if_else(isPair, type1 + type2, type1)) %>%
  mutate(., typeID=if_else(typeID == 0, if_else(isPair, as.integer(1), as.integer(0)), as.integer(typeID))) %>%
  mutate(., typeIDstr=factor(typeID, labels = c('unknown-cone', 'unknown-pair', 
                                                'M-cone', 'L-cone', 'M+M-pair', 'L+M-pair', 'L+L-pair')))
tally(trial_data)
```


6. Finally, saturation was computed saturation from a sum of the absolute values of the green-red (gr) and yellow-blue (yb) dimensions ($\mid yb \mid + \mid gr \mid$). Below we see a plot of saturation as a function of type ID. Saturation was similar across all cone types, with exception of the unidentified cones in S20075. This subject reported more saturated sensations than the other two subjects
```{r saturation, fig.height=3, fig.width=9}
trial_data <- mutate(trial_data, saturation = abs(yb) + abs(gr))

ggplot(trial_data, aes(x=saturation)) + 
  geom_histogram(binwidth=0.1) + facet_grid(. ~ typeIDstr)
```

# Results

## Variability in sensations from cones with the same sensitivity

We first grouped each trial based on the subject, cone targeted (masterID) and type of cone or pair probed. We then found them mean of each group and plotted yellow-blue (yb) and green-red (gr) dimensions below. In both subjects with classified cones, individual and pairs of M-cones produced gr means that were greater than zero, while L-cone conditions led to negative values. This suggests that cone type may be predictive of the color reported by the subject, as found previously (Sabesan et al. 2016; Schmidt et al. 2018)

```{r}
(typeGroup <- trial_data %>%
  group_by(., subject, typeIDstr) %>% 
  summarise(., by_mean=signif(mean(yb), 3), 
            by_std=signif(sd(yb), 3), 
            gr_mean=signif(mean(gr), 3), 
            gr_std=signif(sd(gr), 3), N=length(gr))
 )

```

The plot below illustrates the spread of the data in each subject.

```{r}
singleAndPairs <- trial_data %>%
  select(., -typeIDstr) %>%
  group_by(., subject, masterID1, masterID2) %>% 
  summarise_all(., mean)

boundary <- data.frame(x=c(-1, 0, 1, 0, -1), y=c(0, 1, 0, -1, 0))

ggplot(data=singleAndPairs, aes(x=yb, y=gr, color=as.factor(typeID))) + 
  geom_point(alpha=0.6, size=0.4) +
  facet_grid(. ~ subject) +
  geom_rug(alpha=0.4) + 
  coord_equal(xlim=c(-1, 1), ylim=c(-1, 1)) + 
  xlab('(yellow - blue) / total') + ylab('(green - red) / total') + 
  scale_color_manual(
    values = c("black", "black", "#3aaf4f", "#d1463e", "#3aaf4f", "#AAAA00", "#d1463e"), 
    name="spectral type",
    labels = c("unknown-cone", "unknown-pair", "M-cone", "L-cone", "M+M-pair", "L+M-pair", "L+L-pair")) +
  #scale_color_brewer(palette = "Spectral") +
  geom_path(data = boundary, aes(x=x, y=y), colour='gray', linetype=2) +
  theme_bw()

ggsave("lms_UAD.pdf")
```

There are a few features to notice. Firstly, there is some individual variability. S20075 used blue more frequently than the two other subjects and S10001 did not report yellow on any trials. However, the general patterns are similar. Most of the variance was found along the green-red dimension and there were no points that fell in the blueish-red or greenish-yellow dimension. In the two subjects with classified mosaics, we additionally see that L-cone targeted trials tended to fall along the red region of this space, while M-cones were more likely to fall in the green dimension.

## Mosaic parameters do not predict responses

Next, we grouped the data according to the number of cones targeted (one or two), the session in which trial occurred and the specific cone(s) that was targeted. The mean and count was then computed for each cone(s). Next, we select only those cones pairs which had at least four good trials. Finally, the length columns are dropped and columns are renamed to remove "_mean" so that the original names are preserved.

```{r}
singleConesSummary <- trial_data %>% 
  select(., -typeIDstr) %>%
  filter(., isPair==FALSE) %>% 
  group_by(., subject, session, masterID1) %>%   
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

twoConesSummary <- trial_data %>%   
  select(., -typeIDstr) %>%
  filter(., isPair==TRUE) %>% 
  group_by(., subject, session, masterID1, masterID2) %>%
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))
```

Using the data generated above, we visualized the relationship between measured response dimensions and predictor variables for the one and two cone conditions.

```{r}
# scatterplotMatrix with car package
scatterplotMatrix(singleConesSummary[ ,c("yb", "gr", "saturation", 
                                         "lConeNeighbors")],
                  diagonal=list(method ="histogram"),
                  ellipse=FALSE)

scatterplotMatrix(twoConesSummary[ ,c("yb", "gr", "saturation", 
                                      "lConeNeighbors",
                                      "distance_btwn_cones_pix")],
                  diagonal=list(method ="histogram"),
                  ellipse=FALSE)
```


None of the above correlation plots were statistically significant. The local neighborhood surrounding a cone is typically thought to be an important factor in generating color sensations. However, we do not find a strong relationship. The distance between cones may also be an important factor influencing appearance. Neither color nor saturation judgments were correlated with the distance between targeted cones (plotted here in pixels). Cone pairs were never separated by more than one cone, which likely explains why there was no relationship.

## Two cone responses are an average of individual reports

Next, we were interested in whether the reports from from each individual cones in a pair predicted the color they produced when stimulated together. To answer this question, we created a merged data frame with the responses from each individual cone matched up with the judgments from their paired stimulation.

```{r}

singleConesSummary <- trial_data %>%
  select(., -typeIDstr) %>%
  filter(., isPair==FALSE) %>% 
  group_by(., subject, session, masterID1) %>%   
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

twoConesSummary <- trial_data %>%
  select(., -typeIDstr) %>%
  filter(., isPair==TRUE) %>% 
  group_by(., subject, session, masterID1, masterID2) %>%
  summarise_all(., c("mean", "length")) %>%
  filter(., yb_length > 3) %>%
  select(., -contains("_length")) %>%
  rename_(.dots=setNames(names(.), gsub("_mean", "", names(.))))

merged1 <- merge(twoConesSummary, 
           select(singleConesSummary, subject, 
                  session, masterID1, yb, gr, lConeNeighbors), 
           by=c("subject", "session", "masterID1")) %>% 
  rename(., yb12=yb.x, gr12=gr.x, yb1=yb.y, gr1=gr.y,
                  lConeNeighbors12=lConeNeighbors.x, 
                  lConeNeighbors1=lConeNeighbors.y)

sessionMerge <- merged1 %>% 
  merge(., select(singleConesSummary, subject, session,
                  masterID1, yb, gr, lConeNeighbors), 
        by.x=c("subject", "session", "masterID2"),
        by.y=c("subject", "session", "masterID1")) %>% 
  rename(., yb2=yb, gr2=gr, lConeNeighbors2=lConeNeighbors) %>%
  mutate(., saturation12=abs(yb12) + abs(gr12),
         saturation1=abs(yb1) + abs(gr1),
         saturation2=abs(yb2) + abs(gr2))
```


After merging and sorting the data, we fit a linear model to the data, which predicts behavioral reports from two cone stimulation based on an average of the individual responses: $gr_{12} = (gr_1 + gr_2) / 2$. Below is a visualization of the measured responses against the predictions.


```{r}
unity = data.frame(x=c(-1, 1), y=c(-1, 1))
ggplot(data=sessionMerge, aes(x=(gr1 + gr2) / 2, y=gr12)) + 
  geom_point() +
  geom_smooth(method=lm) +
  coord_equal(xlim=c(-1, 1), ylim=c(-1, 1)) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  ggtitle('green - red / total') +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  xlab('average of individual responses') + ylab('observed two-cone response') + 
  theme_classic(base_size=15)

ggsave("prediction_gr.pdf")


unity = data.frame(x=c(-1, 1), y=c(-1, 1))
ggplot(data=sessionMerge, aes(x=(yb1 + yb2) / 2, y=yb12)) + 
  geom_point() +
  geom_smooth(method=lm) +
  coord_equal(xlim=c(-1, 1), ylim=c(-1, 1)) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  ggtitle('yellow - blue / total') +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) +
  xlab('average of individual responses') + ylab('observed two-cone response') + 
  theme_classic(base_size=15)

ggsave("prediction_yb.pdf")
```

```{r}
# A linear model predicts the results based on an average of the individual responses.
mod <- lm((gr1 + gr2) / 2 ~ gr12, sessionMerge)
summary.lm(mod)


mod <- lm((yb1 + yb2) / 2 ~ yb12, sessionMerge)
summary.lm(mod)
```


## Pairs with the same type are more saturated than predicted by average

Finally, we look at the error terms of our prediction as a function of the cone types probed.

```{r}
# Add a column w difference from prediction
sessionMerge <- mutate(sessionMerge, 
                       diff_from_prediction=saturation12 - 
                         ((saturation1 + saturation2) / 2))

```

Notice that the L+L and M+M pairs tend to fall above the unity line. This is especially true as saturation increases. In contrast, the L+M pairs fall below the line. These observations indicate that the cones with the same spectral type produced slightly more saturated reports than predicted by the average of their individual responses.

```{r}
ggplot(data=filter(sessionMerge, typeID > 3), 
       aes(x=(saturation1 + saturation2) / 2, y=saturation12, color=as.factor(typeID))) + 
  geom_point() + 
  coord_equal(xlim=c(0, 1), ylim=c(0, 1)) +
  scale_color_manual(values = c("green", "yellow", "red"), name="spectral type",
                     labels = c("M+M", "L+M", "L+L")) +
  geom_path(data=unity, aes(x=x, y=y), colour='gray', linetype=1) + 
  xlab('predicted saturation (average of individual)') +
  ylab('measured saturation') +
  theme_classic(base_size=15)

```

These trends were quantified directly by taking the difference between the observed and predicted saturation judgments. The histogram below illustrates the point outlined above. As the t-test's below demonstrate, the L+M pairs were significantly less saturated (more white) than a simple average of their individual responses, while the opposite was true for cones with the same spectral type.

```{r}
ggplot(data=filter(sessionMerge, typeID > 3), 
       aes(x=saturation12 - ((saturation1 + saturation2) / 2), 
           color=as.factor(typeID))) + 
  geom_freqpoly(binwidth=0.1) +
  scale_color_manual(
    values = c("green", "yellow", "red"), 
    name="spectral type",
    labels = c("M+M", "L+M", "L+L")) + 
  xlab("observed - predicted saturation") +
  theme_classic(base_size=15)

ggsave('observed-predicted_histogram.pdf')

```


```{r}

t.test(sessionMerge %>% 
         filter(., typeID == 5) %>% 
         select(., diff_from_prediction)
       )
t.test(sessionMerge %>% 
         filter(., typeID == 4 | typeID == 6) %>%
         select(., diff_from_prediction)
       )

t.test(sessionMerge %>% 
         filter(., typeID == 5) %>% 
         select(., diff_from_prediction),
       sessionMerge %>% 
         filter(., typeID == 4 | typeID == 6) %>%
         select(., diff_from_prediction)
       )
```

# Conclusions

Color sensations from pairs of cones were predicted by a simple average of individual responses. However, when two cones from the same subclass were probed, there was a systematic deviation from an average. These pairs produced significantly more saturated colors than predicted by an average of the colors elicited when probed alone.

